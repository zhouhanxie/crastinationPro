package com.example.crastinationpro;

import android.util.Log;

import java.io.Serializable;
import java.sql.Time;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.lang.Math;
import java.util.StringTokenizer;

public class Event implements Comparable<Event>{

    static int algorithm = 0; //0 for default by due date, 1 for priority based
    public String date;
    public String time;
    public String note;
    public String priority;
    public String bursttime;
    public int id; //this is a unique ID, generated by sqllite and assignment upon fetch
    Event(String date_, String time_, String note_, String priority_, String bursttime_)
    {
        date = date_;
        time = time_;
        note = note_;
        priority = priority_;
        bursttime =bursttime_;
        id = -1;
    }
    Event(String data, int sqlid) {
        StringTokenizer st = new StringTokenizer(data, "$|#$");
        int i = 0;
        date = "N/A"; time = "N/A"; note="N/A"; priority = "N/A"; bursttime = "N/A";
        while (st.hasMoreTokens())
        {
            switch(i)
            {
                case 0:
                    date = st.nextToken();
                    break;
                case 1:
                    time = st.nextToken();
                    break;
                case 2:
                    note = st.nextToken();
                    break;
                case 3:
                    priority = st.nextToken();
                    break;
                case 4:
                    bursttime = st.nextToken();
                    break;
            }
            i++;
        }
        id = sqlid;
    }
    public String getNote()
    {
        return note;
    }
    public String getPriority()
    {
        return priority;
    }
    public String getBursttime()
    {
        return bursttime;
    }
    public String getDate()
    {
        return date;
    }
    public String getTime()
    {
        return time;
    }
    int negative_to_maxint(int n)
    {
        if (n<0)
            return Integer.MAX_VALUE;
        return n;
    }
    public String getTitle(){return note.substring(0, Math.min(Math.min(note.length(), 20), negative_to_maxint(note.indexOf("\n"))));}
    public String toStringData()
    {
        String res = "";
        String delim = "$|#$";
        res += date+delim+time+delim+note+delim+priority+delim+bursttime;
        return res;
    }


    public int earlierThan(Event that)
    {
        SimpleDateFormat dform = new SimpleDateFormat("MM/dd/yy");
        SimpleDateFormat tform = new SimpleDateFormat("hh:mm");
        try
        {
            if (dform.parse(this.date).before(dform.parse(that.getDate())))
            {
                return 1;
            }
            else if (dform.parse(this.date).after(dform.parse(that.getDate())))
            {
                return -1;
            }
            //otherwise date is the same
            if (tform.parse(this.time).before(tform.parse(that.getTime())))
            {
                return 1;
            }
            else if (tform.parse(this.time).after(dform.parse(that.getTime())))
            {
                return -1;
            }
            return 0;

        }
        catch (java.text.ParseException tpe)
        {
            return -2;
        }
    }
    public int compareTo(Event that)
    {
        int r = this.earlierThan(that);
        if (r==-2)
        {
            Log.e("Event object :", "parsing string, something is wrong");
        }
        return r;
    }

    public String getContent()
    {
        return note;
    }

    public int getId(){return id;}
}
